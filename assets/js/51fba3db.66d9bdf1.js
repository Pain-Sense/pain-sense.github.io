"use strict";(self.webpackChunkpain_sense=self.webpackChunkpain_sense||[]).push([[975],{2949:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var s=i(4848),r=i(8453);const t={},o=void 0,a={id:"Development/ESP32",title:"ESP32",description:"ESP32-WROOM-32 Programming and Integration",source:"@site/docs/Development/ESP32.md",sourceDirName:"Development",slug:"/Development/ESP32",permalink:"/docs/Development/ESP32",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"projectSidebar",previous:{title:"Development",permalink:"/docs/category/development"},next:{title:"FrontEnd",permalink:"/docs/Development/FrontEnd"}},l={},d=[{value:"ESP32-WROOM-32 Programming and Integration",id:"esp32-wroom-32-programming-and-integration",level:2},{value:"Development Approach",id:"development-approach",level:3},{value:"Libraries Used",id:"libraries-used",level:3},{value:"Wi-Fi Reconfiguration via WiFiManager",id:"wi-fi-reconfiguration-via-wifimanager",level:3},{value:"Robustness Features",id:"robustness-features",level:3},{value:"MQTT Message Structure",id:"mqtt-message-structure",level:3}];function c(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"esp32-wroom-32-programming-and-integration",children:"ESP32-WROOM-32 Programming and Integration"}),"\n",(0,s.jsxs)(n.p,{children:["To program the ESP32-WROOM-32 microcontroller, the ",(0,s.jsx)(n.strong,{children:"Arduino IDE"}),"  was used \u2014 a development environment widely adopted in embedded systems for its simplicity and broad library support."]}),"\n",(0,s.jsx)(n.h3,{id:"development-approach",children:"Development Approach"}),"\n",(0,s.jsx)(n.p,{children:"Using Arduino IDE allowed for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Easy flashing of code to the microcontroller."}),"\n",(0,s.jsx)(n.li,{children:"Basic debugging and serial monitoring."}),"\n",(0,s.jsx)(n.li,{children:"Quick visualization of the data being transmitted by the ESP32."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The code was developed with a modular structure, separating:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Sensor data acquisition logic"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Data transmission"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Wi-Fi connection management"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"libraries-used",children:"Libraries Used"}),"\n",(0,s.jsx)(n.p,{children:"The following libraries were integrated:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"WiFi.h"}),": for basic wireless communication."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"WiFiManager.h"})," : to simplify Wi-Fi configuration using a local web portal."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DFRobot_Heartrate"}),": to read data from the PPG sensor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RTClib"}),": for interfacing with the Real-Time Clock (RTC) module."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PubSubClient"}),": for publishing sensor data to an MQTT broker."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Additional routines were implemented for ",(0,s.jsx)(n.strong,{children:"periodic sensor readings"}),", specifically for:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"GSR (Galvanic Skin Response)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"PPG (Photoplethysmography / Heart Rate)"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"wi-fi-reconfiguration-via-wifimanager",children:"Wi-Fi Reconfiguration via WiFiManager"}),"\n",(0,s.jsxs)(n.p,{children:["A major usability issue in earlier versions of the project was the need to ",(0,s.jsx)(n.strong,{children:"hardcode Wi-Fi credentials and server information"})," directly into the firmware. This made reconfiguration difficult and error-prone."]}),"\n",(0,s.jsxs)(n.p,{children:["To resolve this, the ",(0,s.jsx)(n.strong,{children:"WiFiManager"})," library was adopted. It allows the ESP32 to:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a temporary Wi-Fi ",(0,s.jsx)(n.strong,{children:"Access Point (AP)"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Launch a local configuration portal accessible from any nearby device."}),"\n",(0,s.jsxs)(n.li,{children:["Let users configure Wi-Fi and password, MQTT broker address, and device ID ",(0,s.jsx)(n.strong,{children:"without reflashing the firmware"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This made the device ",(0,s.jsx)(n.strong,{children:"much more flexible and user-friendly"}),", especially in environments where Wi-Fi credentials may change."]}),"\n",(0,s.jsx)(n.h3,{id:"robustness-features",children:"Robustness Features"}),"\n",(0,s.jsx)(n.p,{children:"To ensure stable performance, especially during extended operation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The ESP32 automatically attempts to reconnect to the Wi-Fi network or restart in case of connection failure or invalid sensor data."}),"\n",(0,s.jsx)(n.li,{children:"This improves resilience and reduces the need for manual resets."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"mqtt-message-structure",children:"MQTT Message Structure"}),"\n",(0,s.jsx)(n.p,{children:"Once connected to the Wi-Fi network and the MQTT broker (e.g., Mosquitto), the ESP32 begins publishing JSON-formatted messages via MQTT. These messages contain the data collected from the sensors and include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"timestamp"}),": exact date and time (microsecond precision) from the RTC module."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bvp"}),": average value from the PPG sensor, linked to heart rate."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"gsr"}),": average value from the GSR sensor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"deviceId"}),": unique identifier of the ESP32 device."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Each sensor reading cycle publishes an ",(0,s.jsx)(n.strong,{children:"aggregated JSON packet"})," to the ",(0,s.jsx)(n.code,{children:"sensors"})," MQTT topic."]}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, the ESP32 also publishes data to ",(0,s.jsx)(n.strong,{children:"dedicated topics"})," for individual sensors:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sensors/ppg"}),": for raw PPG values."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sensors/gsr"}),": for raw GSR values."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This approach allows for ",(0,s.jsx)(n.strong,{children:"synchronized analysis"})," and ",(0,s.jsx)(n.strong,{children:"easy scalability"}),", as sensor-specific and general data streams are both available for downstream processing."]}),"\n",(0,s.jsx)(n.p,{children:"Example of a message to the topic sensors:"}),"\n",(0,s.jsx)("img",{src:"/img/esp32jsonfull.png",alt:"A cute kitten"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Example of a message to the topic  sensors/gsr :"}),"\n",(0,s.jsx)("img",{src:"/img/esp32jsonpartial.png",alt:"A cute kitten"})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);